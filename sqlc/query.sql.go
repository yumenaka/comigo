// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countBooks = `-- name: CountBooks :one

SELECT COUNT(*)
FROM books
WHERE deleted = FALSE
`

// Statistics queries
// Count total books
func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBooksByType = `-- name: CountBooksByType :one
SELECT COUNT(*)
FROM books
WHERE type = ?
  AND deleted = FALSE
`

// Count books by type
func (q *Queries) CountBooksByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooksByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPageInfosByBookID = `-- name: CountPageInfosByBookID :one
SELECT COUNT(*)
FROM page_infos
WHERE book_id = ?
`

// Count media files for a book
func (q *Queries) CountPageInfosByBookID(ctx context.Context, bookID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPageInfosByBookID, bookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)
FROM users
`

// Count total users
func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByRole = `-- name: CountUsersByRole :one
SELECT COUNT(*)
FROM users
WHERE role = ?
`

// Count users by role
func (q *Queries) CountUsersByRole(ctx context.Context, role sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsersByRole, role)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (title, book_id, owner, book_path, store_url, type,
                   child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size,
                   author, isbn, press, published_at, extract_path, extract_num,
                   init_complete, non_utf8zip, zip_text_encoding)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
`

type CreateBookParams struct {
	Title           string
	BookID          string
	Owner           sql.NullString
	BookPath        string
	StoreUrl        string
	Type            string
	ChildBooksNum   sql.NullInt64
	ChildBooksID    sql.NullString
	Depth           sql.NullInt64
	ParentFolder    sql.NullString
	PageCount       sql.NullInt64
	LastReadPage    sql.NullInt64
	FileSize        sql.NullInt64
	Author          sql.NullString
	Isbn            sql.NullString
	Press           sql.NullString
	PublishedAt     sql.NullString
	ExtractPath     sql.NullString
	ExtractNum      sql.NullInt64
	InitComplete    sql.NullBool
	NonUtf8zip      sql.NullBool
	ZipTextEncoding sql.NullString
}

// Create new book
func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBook,
		arg.Title,
		arg.BookID,
		arg.Owner,
		arg.BookPath,
		arg.StoreUrl,
		arg.Type,
		arg.ChildBooksNum,
		arg.ChildBooksID,
		arg.Depth,
		arg.ParentFolder,
		arg.PageCount,
		arg.LastReadPage,
		arg.FileSize,
		arg.Author,
		arg.Isbn,
		arg.Press,
		arg.PublishedAt,
		arg.ExtractPath,
		arg.ExtractNum,
		arg.InitComplete,
		arg.NonUtf8zip,
		arg.ZipTextEncoding,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.BookPath,
		&i.StoreUrl,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.LastReadPage,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (type, book_id, page_index, description, created_at, updated_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, type, book_id, page_index, description, created_at, updated_at
`

type CreateBookmarkParams struct {
	Type        string
	BookID      string
	PageIndex   int64
	Description sql.NullString
}

// Create a bookmark
func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, createBookmark,
		arg.Type,
		arg.BookID,
		arg.PageIndex,
		arg.Description,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BookID,
		&i.PageIndex,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPageInfo = `-- name: CreatePageInfo :one
INSERT INTO page_infos (book_id, name, path, size, mod_time, url, page_num,
                         blurhash, height, width, img_type, insert_html)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html
`

type CreatePageInfoParams struct {
	BookID     string
	Name       string
	Path       sql.NullString
	Size       sql.NullInt64
	ModTime    sql.NullTime
	Url        sql.NullString
	PageNum    sql.NullInt64
	Blurhash   sql.NullString
	Height     sql.NullInt64
	Width      sql.NullInt64
	ImgType    sql.NullString
	InsertHtml sql.NullString
}

// Create media file record
func (q *Queries) CreatePageInfo(ctx context.Context, arg CreatePageInfoParams) (PageInfo, error) {
	row := q.db.QueryRowContext(ctx, createPageInfo,
		arg.BookID,
		arg.Name,
		arg.Path,
		arg.Size,
		arg.ModTime,
		arg.Url,
		arg.PageNum,
		arg.Blurhash,
		arg.Height,
		arg.Width,
		arg.ImgType,
		arg.InsertHtml,
	)
	var i PageInfo
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Name,
		&i.Path,
		&i.Size,
		&i.ModTime,
		&i.Url,
		&i.PageNum,
		&i.Blurhash,
		&i.Height,
		&i.Width,
		&i.ImgType,
		&i.InsertHtml,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password, role, email, key, expires_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, username, password, role, email, "key", expires_at, created_at, updated_at
`

type CreateUserParams struct {
	Username  string
	Password  string
	Role      sql.NullString
	Email     sql.NullString
	Key       sql.NullString
	ExpiresAt sql.NullTime
}

// Create new user
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Role,
		arg.Email,
		arg.Key,
		arg.ExpiresAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.Email,
		&i.Key,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE
FROM books
WHERE book_id = ?
`

// Delete book
func (q *Queries) DeleteBook(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, deleteBook, bookID)
	return err
}

const deleteBookmarkByBookIDAndType = `-- name: DeleteBookmarkByBookIDAndType :exec
DELETE
FROM bookmarks
WHERE book_id = ?
  AND type = ?
`

type DeleteBookmarkByBookIDAndTypeParams struct {
	BookID string
	Type   string
}

// Delete a bookmark by (book_id, type)
func (q *Queries) DeleteBookmarkByBookIDAndType(ctx context.Context, arg DeleteBookmarkByBookIDAndTypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteBookmarkByBookIDAndType, arg.BookID, arg.Type)
	return err
}

const deleteBookmarksByBookID = `-- name: DeleteBookmarksByBookID :exec
DELETE
FROM bookmarks
WHERE book_id = ?
`

// Delete all bookmarks for a book
func (q *Queries) DeleteBookmarksByBookID(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, deleteBookmarksByBookID, bookID)
	return err
}

const deletePageInfosByBookID = `-- name: DeletePageInfosByBookID :exec
DELETE
FROM page_infos
WHERE book_id = ?
`

// Delete all media files for a book
func (q *Queries) DeletePageInfosByBookID(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, deletePageInfosByBookID, bookID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = ?
`

// Delete user
func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getBookByBookPath = `-- name: GetBookByBookPath :one
SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
WHERE book_path = ?
LIMIT 1
`

// Get book by file path
func (q *Queries) GetBookByBookPath(ctx context.Context, bookPath string) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByBookPath, bookPath)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.BookPath,
		&i.StoreUrl,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.LastReadPage,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const getBookByID = `-- name: GetBookByID :one

SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
WHERE book_id = ?
LIMIT 1
`

// Book related queries
// Get single book by ID
func (q *Queries) GetBookByID(ctx context.Context, bookID string) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByID, bookID)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.BookPath,
		&i.StoreUrl,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.LastReadPage,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const getPageInfoByBookIDAndPage = `-- name: GetPageInfoByBookIDAndPage :one
SELECT id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html
FROM page_infos
WHERE book_id = ?
  AND page_num = ?
LIMIT 1
`

type GetPageInfoByBookIDAndPageParams struct {
	BookID  string
	PageNum sql.NullInt64
}

// Get specific page by book ID and page number
func (q *Queries) GetPageInfoByBookIDAndPage(ctx context.Context, arg GetPageInfoByBookIDAndPageParams) (PageInfo, error) {
	row := q.db.QueryRowContext(ctx, getPageInfoByBookIDAndPage, arg.BookID, arg.PageNum)
	var i PageInfo
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Name,
		&i.Path,
		&i.Size,
		&i.ModTime,
		&i.Url,
		&i.PageNum,
		&i.Blurhash,
		&i.Height,
		&i.Width,
		&i.ImgType,
		&i.InsertHtml,
	)
	return i, err
}

const getPageInfosByBookID = `-- name: GetPageInfosByBookID :many

SELECT id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html
FROM page_infos
WHERE book_id = ?
ORDER BY page_num
`

// Media files related queries
// Get all page information by book ID
func (q *Queries) GetPageInfosByBookID(ctx context.Context, bookID string) ([]PageInfo, error) {
	rows, err := q.db.QueryContext(ctx, getPageInfosByBookID, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PageInfo
	for rows.Next() {
		var i PageInfo
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Name,
			&i.Path,
			&i.Size,
			&i.ModTime,
			&i.Url,
			&i.PageNum,
			&i.Blurhash,
			&i.Height,
			&i.Width,
			&i.ImgType,
			&i.InsertHtml,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, password, role, email, "key", expires_at, created_at, updated_at
FROM users
WHERE email = ?
LIMIT 1
`

// Get user by email
func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.Email,
		&i.Key,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, password, role, email, "key", expires_at, created_at, updated_at
FROM users
WHERE id = ?
LIMIT 1
`

// User related queries
// Get user by ID
func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.Email,
		&i.Key,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, role, email, "key", expires_at, created_at, updated_at
FROM users
WHERE username = ?
LIMIT 1
`

// Get user by username
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.Email,
		&i.Key,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllBookStoreURLs = `-- name: ListAllBookStoreURLs :many
SELECT DISTINCT store_url
FROM books
`

// get all store_url for books
func (q *Queries) ListAllBookStoreURLs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllBookStoreURLs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var store_url string
		if err := rows.Scan(&store_url); err != nil {
			return nil, err
		}
		items = append(items, store_url)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookmarksByBookID = `-- name: ListBookmarksByBookID :many

SELECT id, type, book_id, page_index, description, created_at, updated_at
FROM bookmarks
WHERE book_id = ?
ORDER BY created_at DESC
`

// Bookmarks related queries
// List bookmarks by book ID
func (q *Queries) ListBookmarksByBookID(ctx context.Context, bookID string) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarksByBookID, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BookID,
			&i.PageIndex,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
ORDER BY modified_time DESC
`

// List all books
func (q *Queries) ListBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.BookPath,
			&i.StoreUrl,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.LastReadPage,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByStorePath = `-- name: ListBooksByStorePath :many
SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
WHERE store_url = ?
ORDER BY modified_time DESC
`

// List books by store path
func (q *Queries) ListBooksByStorePath(ctx context.Context, storeUrl string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByStorePath, storeUrl)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.BookPath,
			&i.StoreUrl,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.LastReadPage,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByType = `-- name: ListBooksByType :many
SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
WHERE type = ?
ORDER BY modified_time DESC
`

// List books by type
func (q *Queries) ListBooksByType(ctx context.Context, type_ string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.BookPath,
			&i.StoreUrl,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.LastReadPage,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, password, role, email, "key", expires_at, created_at, updated_at
FROM users
ORDER BY created_at DESC
`

// List all users
func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Role,
			&i.Email,
			&i.Key,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBookAsDeleted = `-- name: MarkBookAsDeleted :exec
UPDATE books
SET deleted       = TRUE,
    modified_time = CURRENT_TIMESTAMP
WHERE book_id = ?
`

// Mark book as deleted (soft delete)
func (q *Queries) MarkBookAsDeleted(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, markBookAsDeleted, bookID)
	return err
}

const searchBooksByTitle = `-- name: SearchBooksByTitle :many
SELECT id, title, book_id, owner, book_path, store_url, type, child_books_num, child_books_id, depth, parent_folder, page_count, last_read_page, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, non_utf8zip, zip_text_encoding, deleted
FROM books
WHERE title LIKE '%' || ? || '%'
ORDER BY modified_time DESC
`

// Search books by title (fuzzy search)
func (q *Queries) SearchBooksByTitle(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, searchBooksByTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.BookPath,
			&i.StoreUrl,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.LastReadPage,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :exec
UPDATE books
SET title             = ?,
    owner             = ?,
    book_path         = ?,
    store_url         = ?,
    type              = ?,
    child_books_num   = ?,
    child_books_id    = ?,
    depth             = ?,
    parent_folder     = ?,
    page_count        = ?,
    last_read_page    = ?,
    file_size         = ?,
    author            = ?,
    isbn              = ?,
    press             = ?,
    published_at      = ?,
    extract_path      = ?,
    extract_num       = ?,
    init_complete     = ?,
    non_utf8zip       = ?,
    zip_text_encoding = ?,
    modified_time     = CURRENT_TIMESTAMP
WHERE book_id = ?
`

type UpdateBookParams struct {
	Title           string
	Owner           sql.NullString
	BookPath        string
	StoreUrl        string
	Type            string
	ChildBooksNum   sql.NullInt64
	ChildBooksID    sql.NullString
	Depth           sql.NullInt64
	ParentFolder    sql.NullString
	PageCount       sql.NullInt64
	LastReadPage    sql.NullInt64
	FileSize        sql.NullInt64
	Author          sql.NullString
	Isbn            sql.NullString
	Press           sql.NullString
	PublishedAt     sql.NullString
	ExtractPath     sql.NullString
	ExtractNum      sql.NullInt64
	InitComplete    sql.NullBool
	NonUtf8zip      sql.NullBool
	ZipTextEncoding sql.NullString
	BookID          string
}

// Update book information
func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.ExecContext(ctx, updateBook,
		arg.Title,
		arg.Owner,
		arg.BookPath,
		arg.StoreUrl,
		arg.Type,
		arg.ChildBooksNum,
		arg.ChildBooksID,
		arg.Depth,
		arg.ParentFolder,
		arg.PageCount,
		arg.LastReadPage,
		arg.FileSize,
		arg.Author,
		arg.Isbn,
		arg.Press,
		arg.PublishedAt,
		arg.ExtractPath,
		arg.ExtractNum,
		arg.InitComplete,
		arg.NonUtf8zip,
		arg.ZipTextEncoding,
		arg.BookID,
	)
	return err
}

const updateBookmark = `-- name: UpdateBookmark :exec
UPDATE bookmarks
SET description = ?,
    page_index  = ?,
    description = ?,
    updated_at  = CURRENT_TIMESTAMP
WHERE book_id = ? and type = ?
`

type UpdateBookmarkParams struct {
	Description   sql.NullString
	PageIndex     int64
	Description_2 sql.NullString
	BookID        string
	Type          string
}

// Update a bookmark (by book_id, type)
func (q *Queries) UpdateBookmark(ctx context.Context, arg UpdateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmark,
		arg.Description,
		arg.PageIndex,
		arg.Description_2,
		arg.BookID,
		arg.Type,
	)
	return err
}

const updateLastReadPage = `-- name: UpdateLastReadPage :exec
UPDATE bookmarks
SET page_index = ?,
    type  = ?,
    updated_at  = CURRENT_TIMESTAMP
WHERE book_id = ?
`

type UpdateLastReadPageParams struct {
	PageIndex int64
	Type      string
	BookID    string
}

// Update reading progress
func (q *Queries) UpdateLastReadPage(ctx context.Context, arg UpdateLastReadPageParams) error {
	_, err := q.db.ExecContext(ctx, updateLastReadPage, arg.PageIndex, arg.Type, arg.BookID)
	return err
}

const updatePageInfo = `-- name: UpdatePageInfo :exec
UPDATE page_infos
SET name        = ?,
    path        = ?,
    size        = ?,
    mod_time    = ?,
    url         = ?,
    blurhash    = ?,
    height      = ?,
    width       = ?,
    img_type    = ?,
    insert_html = ?
WHERE book_id = ?
  AND page_num = ?
`

type UpdatePageInfoParams struct {
	Name       string
	Path       sql.NullString
	Size       sql.NullInt64
	ModTime    sql.NullTime
	Url        sql.NullString
	Blurhash   sql.NullString
	Height     sql.NullInt64
	Width      sql.NullInt64
	ImgType    sql.NullString
	InsertHtml sql.NullString
	BookID     string
	PageNum    sql.NullInt64
}

// Update media file information
func (q *Queries) UpdatePageInfo(ctx context.Context, arg UpdatePageInfoParams) error {
	_, err := q.db.ExecContext(ctx, updatePageInfo,
		arg.Name,
		arg.Path,
		arg.Size,
		arg.ModTime,
		arg.Url,
		arg.Blurhash,
		arg.Height,
		arg.Width,
		arg.ImgType,
		arg.InsertHtml,
		arg.BookID,
		arg.PageNum,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET username   = ?,
    password   = ?,
    role       = ?,
    email      = ?,
    key        = ?,
    expires_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateUserParams struct {
	Username  string
	Password  string
	Role      sql.NullString
	Email     sql.NullString
	Key       sql.NullString
	ExpiresAt sql.NullTime
	ID        int64
}

// Update user information
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Username,
		arg.Password,
		arg.Role,
		arg.Email,
		arg.Key,
		arg.ExpiresAt,
		arg.ID,
	)
	return err
}

const updateUserKey = `-- name: UpdateUserKey :exec
UPDATE users
SET key        = ?,
    expires_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateUserKeyParams struct {
	Key       sql.NullString
	ExpiresAt sql.NullTime
	ID        int64
}

// Update user key and expiration
func (q *Queries) UpdateUserKey(ctx context.Context, arg UpdateUserKeyParams) error {
	_, err := q.db.ExecContext(ctx, updateUserKey, arg.Key, arg.ExpiresAt, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password   = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	Password string
	ID       int64
}

// Update user password
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.Password, arg.ID)
	return err
}
