// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countBooks = `-- name: CountBooks :one

SELECT COUNT(*) FROM books WHERE deleted = FALSE
`

// Statistics queries
// Count total books
func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBooksByType = `-- name: CountBooksByType :one
SELECT COUNT(*) FROM books WHERE type = ? AND deleted = FALSE
`

// Count books by type
func (q *Queries) CountBooksByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooksByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFileBackendsByType = `-- name: CountFileBackendsByType :one
SELECT COUNT(*) FROM file_backends WHERE type = ?
`

// Count file backends by type
func (q *Queries) CountFileBackendsByType(ctx context.Context, type_ int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFileBackendsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMediaFilesByBookID = `-- name: CountMediaFilesByBookID :one
SELECT COUNT(*) FROM media_files WHERE book_id = ?
`

// Count media files for a book
func (q *Queries) CountMediaFilesByBookID(ctx context.Context, bookID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMediaFilesByBookID, bookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStores = `-- name: CountStores :one
SELECT COUNT(*) FROM stores
`

// Count total stores
func (q *Queries) CountStores(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStores)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (
    title, book_id, owner, file_path, book_store_path, type,
    child_books_num, child_books_id,depth, parent_folder, page_count, file_size,
    author, isbn, press, published_at, extract_path, extract_num,
    init_complete, read_percent, non_utf8zip, zip_text_encoding
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted
`

type CreateBookParams struct {
	Title           string
	BookID          string
	Owner           sql.NullString
	FilePath        string
	BookStorePath   string
	Type            string
	ChildBooksNum   sql.NullInt64
	ChildBooksID    sql.NullString
	Depth           sql.NullInt64
	ParentFolder    sql.NullString
	PageCount       sql.NullInt64
	FileSize        sql.NullInt64
	Author          sql.NullString
	Isbn            sql.NullString
	Press           sql.NullString
	PublishedAt     sql.NullString
	ExtractPath     sql.NullString
	ExtractNum      sql.NullInt64
	InitComplete    sql.NullBool
	ReadPercent     sql.NullFloat64
	NonUtf8zip      sql.NullBool
	ZipTextEncoding sql.NullString
}

// Create new book
func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBook,
		arg.Title,
		arg.BookID,
		arg.Owner,
		arg.FilePath,
		arg.BookStorePath,
		arg.Type,
		arg.ChildBooksNum,
		arg.ChildBooksID,
		arg.Depth,
		arg.ParentFolder,
		arg.PageCount,
		arg.FileSize,
		arg.Author,
		arg.Isbn,
		arg.Press,
		arg.PublishedAt,
		arg.ExtractPath,
		arg.ExtractNum,
		arg.InitComplete,
		arg.ReadPercent,
		arg.NonUtf8zip,
		arg.ZipTextEncoding,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.FilePath,
		&i.BookStorePath,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.ReadPercent,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const createFileBackend = `-- name: CreateFileBackend :one
INSERT INTO file_backends (
    type, url, server_host, server_port, need_auth, auth_username,
    auth_password, smb_share_name, smb_path
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, type, url, server_host, server_port, need_auth, auth_username, auth_password, smb_share_name, smb_path, created_at, updated_at
`

type CreateFileBackendParams struct {
	Type         int64
	Url          string
	ServerHost   sql.NullString
	ServerPort   sql.NullInt64
	NeedAuth     sql.NullBool
	AuthUsername sql.NullString
	AuthPassword sql.NullString
	SmbShareName sql.NullString
	SmbPath      sql.NullString
}

// Create file backend
func (q *Queries) CreateFileBackend(ctx context.Context, arg CreateFileBackendParams) (FileBackend, error) {
	row := q.db.QueryRowContext(ctx, createFileBackend,
		arg.Type,
		arg.Url,
		arg.ServerHost,
		arg.ServerPort,
		arg.NeedAuth,
		arg.AuthUsername,
		arg.AuthPassword,
		arg.SmbShareName,
		arg.SmbPath,
	)
	var i FileBackend
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Url,
		&i.ServerHost,
		&i.ServerPort,
		&i.NeedAuth,
		&i.AuthUsername,
		&i.AuthPassword,
		&i.SmbShareName,
		&i.SmbPath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMediaFile = `-- name: CreateMediaFile :one
INSERT INTO media_files (
    book_id, name, path, size, mod_time, url, page_num,
    blurhash, height, width, img_type, insert_html
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html
`

type CreateMediaFileParams struct {
	BookID     string
	Name       string
	Path       sql.NullString
	Size       sql.NullInt64
	ModTime    sql.NullTime
	Url        sql.NullString
	PageNum    sql.NullInt64
	Blurhash   sql.NullString
	Height     sql.NullInt64
	Width      sql.NullInt64
	ImgType    sql.NullString
	InsertHtml sql.NullString
}

// Create media file record
func (q *Queries) CreateMediaFile(ctx context.Context, arg CreateMediaFileParams) (MediaFile, error) {
	row := q.db.QueryRowContext(ctx, createMediaFile,
		arg.BookID,
		arg.Name,
		arg.Path,
		arg.Size,
		arg.ModTime,
		arg.Url,
		arg.PageNum,
		arg.Blurhash,
		arg.Height,
		arg.Width,
		arg.ImgType,
		arg.InsertHtml,
	)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Name,
		&i.Path,
		&i.Size,
		&i.ModTime,
		&i.Url,
		&i.PageNum,
		&i.Blurhash,
		&i.Height,
		&i.Width,
		&i.ImgType,
		&i.InsertHtml,
	)
	return i, err
}

const createStore = `-- name: CreateStore :one
INSERT INTO stores (
    name, description, file_backend_id
) VALUES (
    ?, ?, ?
) RETURNING id, name, description, file_backend_id, created_at, updated_at
`

type CreateStoreParams struct {
	Name          string
	Description   sql.NullString
	FileBackendID int64
}

// Create store
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStore, arg.Name, arg.Description, arg.FileBackendID)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FileBackendID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM books WHERE book_id = ?
`

// Delete book
func (q *Queries) DeleteBook(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, deleteBook, bookID)
	return err
}

const deleteFileBackend = `-- name: DeleteFileBackend :exec
DELETE FROM file_backends WHERE id = ?
`

// Delete file backend
func (q *Queries) DeleteFileBackend(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFileBackend, id)
	return err
}

const deleteMediaFilesByBookID = `-- name: DeleteMediaFilesByBookID :exec
DELETE FROM media_files WHERE book_id = ?
`

// Delete all media files for a book
func (q *Queries) DeleteMediaFilesByBookID(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, deleteMediaFilesByBookID, bookID)
	return err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM stores WHERE id = ?
`

// Delete store
func (q *Queries) DeleteStore(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStore, id)
	return err
}

const getBookByFilePath = `-- name: GetBookByFilePath :one
SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
WHERE file_path = ? LIMIT 1
`

// Get book by file path
func (q *Queries) GetBookByFilePath(ctx context.Context, filePath string) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByFilePath, filePath)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.FilePath,
		&i.BookStorePath,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.ReadPercent,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const getBookByID = `-- name: GetBookByID :one

SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
WHERE book_id = ? LIMIT 1
`

// Book related queries
// Get single book by ID
func (q *Queries) GetBookByID(ctx context.Context, bookID string) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByID, bookID)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.BookID,
		&i.Owner,
		&i.FilePath,
		&i.BookStorePath,
		&i.Type,
		&i.ChildBooksNum,
		&i.ChildBooksID,
		&i.Depth,
		&i.ParentFolder,
		&i.PageCount,
		&i.FileSize,
		&i.Author,
		&i.Isbn,
		&i.Press,
		&i.PublishedAt,
		&i.ExtractPath,
		&i.ModifiedTime,
		&i.ExtractNum,
		&i.InitComplete,
		&i.ReadPercent,
		&i.NonUtf8zip,
		&i.ZipTextEncoding,
		&i.Deleted,
	)
	return i, err
}

const getBookCover = `-- name: GetBookCover :one
SELECT id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html FROM media_files 
WHERE book_id = ? AND (page_num = 0 OR page_num = 1) 
LIMIT 1
`

// Get book cover (usually page 0 or 1)
func (q *Queries) GetBookCover(ctx context.Context, bookID string) (MediaFile, error) {
	row := q.db.QueryRowContext(ctx, getBookCover, bookID)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Name,
		&i.Path,
		&i.Size,
		&i.ModTime,
		&i.Url,
		&i.PageNum,
		&i.Blurhash,
		&i.Height,
		&i.Width,
		&i.ImgType,
		&i.InsertHtml,
	)
	return i, err
}

const getFileBackendByID = `-- name: GetFileBackendByID :one

SELECT id, type, url, server_host, server_port, need_auth, auth_username, auth_password, smb_share_name, smb_path, created_at, updated_at FROM file_backends 
WHERE id = ? LIMIT 1
`

// File backend related queries
// Get file backend by ID
func (q *Queries) GetFileBackendByID(ctx context.Context, id int64) (FileBackend, error) {
	row := q.db.QueryRowContext(ctx, getFileBackendByID, id)
	var i FileBackend
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Url,
		&i.ServerHost,
		&i.ServerPort,
		&i.NeedAuth,
		&i.AuthUsername,
		&i.AuthPassword,
		&i.SmbShareName,
		&i.SmbPath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaFileByBookIDAndPage = `-- name: GetMediaFileByBookIDAndPage :one
SELECT id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html FROM media_files 
WHERE book_id = ? AND page_num = ? 
LIMIT 1
`

type GetMediaFileByBookIDAndPageParams struct {
	BookID  string
	PageNum sql.NullInt64
}

// Get specific page by book ID and page number
func (q *Queries) GetMediaFileByBookIDAndPage(ctx context.Context, arg GetMediaFileByBookIDAndPageParams) (MediaFile, error) {
	row := q.db.QueryRowContext(ctx, getMediaFileByBookIDAndPage, arg.BookID, arg.PageNum)
	var i MediaFile
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Name,
		&i.Path,
		&i.Size,
		&i.ModTime,
		&i.Url,
		&i.PageNum,
		&i.Blurhash,
		&i.Height,
		&i.Width,
		&i.ImgType,
		&i.InsertHtml,
	)
	return i, err
}

const getMediaFilesByBookID = `-- name: GetMediaFilesByBookID :many

SELECT id, book_id, name, path, size, mod_time, url, page_num, blurhash, height, width, img_type, insert_html FROM media_files 
WHERE book_id = ? 
ORDER BY page_num ASC
`

// Media files related queries
// Get all page information by book ID
func (q *Queries) GetMediaFilesByBookID(ctx context.Context, bookID string) ([]MediaFile, error) {
	rows, err := q.db.QueryContext(ctx, getMediaFilesByBookID, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaFile
	for rows.Next() {
		var i MediaFile
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Name,
			&i.Path,
			&i.Size,
			&i.ModTime,
			&i.Url,
			&i.PageNum,
			&i.Blurhash,
			&i.Height,
			&i.Width,
			&i.ImgType,
			&i.InsertHtml,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByID = `-- name: GetStoreByID :one

SELECT id, name, description, file_backend_id, created_at, updated_at FROM stores 
WHERE id = ? LIMIT 1
`

// Store related queries
// Get store by ID
func (q *Queries) GetStoreByID(ctx context.Context, id int64) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByID, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FileBackendID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreByName = `-- name: GetStoreByName :one
SELECT id, name, description, file_backend_id, created_at, updated_at FROM stores 
WHERE name = ? LIMIT 1
`

// Get store by name
func (q *Queries) GetStoreByName(ctx context.Context, name string) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByName, name)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FileBackendID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreWithBackend = `-- name: GetStoreWithBackend :one
SELECT 
    s.id, s.name, s.description, s.created_at, s.updated_at,
    fb.id as backend_id, fb.type, fb.url, fb.server_host, fb.server_port,
    fb.need_auth, fb.auth_username, fb.auth_password, fb.smb_share_name, fb.smb_path
FROM stores s
JOIN file_backends fb ON s.file_backend_id = fb.id
WHERE s.id = ? LIMIT 1
`

type GetStoreWithBackendRow struct {
	ID           int64
	Name         string
	Description  sql.NullString
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	BackendID    int64
	Type         int64
	Url          string
	ServerHost   sql.NullString
	ServerPort   sql.NullInt64
	NeedAuth     sql.NullBool
	AuthUsername sql.NullString
	AuthPassword sql.NullString
	SmbShareName sql.NullString
	SmbPath      sql.NullString
}

// Get store with file backend information
func (q *Queries) GetStoreWithBackend(ctx context.Context, id int64) (GetStoreWithBackendRow, error) {
	row := q.db.QueryRowContext(ctx, getStoreWithBackend, id)
	var i GetStoreWithBackendRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackendID,
		&i.Type,
		&i.Url,
		&i.ServerHost,
		&i.ServerPort,
		&i.NeedAuth,
		&i.AuthUsername,
		&i.AuthPassword,
		&i.SmbShareName,
		&i.SmbPath,
	)
	return i, err
}

const getTotalFileSize = `-- name: GetTotalFileSize :one
SELECT SUM(file_size) FROM books WHERE deleted = FALSE
`

// Get total file size
func (q *Queries) GetTotalFileSize(ctx context.Context) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getTotalFileSize)
	var sum sql.NullFloat64
	err := row.Scan(&sum)
	return sum, err
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
ORDER BY modified_time DESC
`

// List all books
func (q *Queries) ListBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.FilePath,
			&i.BookStorePath,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.ReadPercent,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByStorePath = `-- name: ListBooksByStorePath :many
SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
WHERE book_store_path = ? 
ORDER BY modified_time DESC
`

// List books by store path
func (q *Queries) ListBooksByStorePath(ctx context.Context, bookStorePath string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByStorePath, bookStorePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.FilePath,
			&i.BookStorePath,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.ReadPercent,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByType = `-- name: ListBooksByType :many
SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
WHERE type = ? 
ORDER BY modified_time DESC
`

// List books by type
func (q *Queries) ListBooksByType(ctx context.Context, type_ string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.FilePath,
			&i.BookStorePath,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.ReadPercent,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFileBackends = `-- name: ListFileBackends :many
SELECT id, type, url, server_host, server_port, need_auth, auth_username, auth_password, smb_share_name, smb_path, created_at, updated_at FROM file_backends 
ORDER BY created_at DESC
`

// List all file backends
func (q *Queries) ListFileBackends(ctx context.Context) ([]FileBackend, error) {
	rows, err := q.db.QueryContext(ctx, listFileBackends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileBackend
	for rows.Next() {
		var i FileBackend
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Url,
			&i.ServerHost,
			&i.ServerPort,
			&i.NeedAuth,
			&i.AuthUsername,
			&i.AuthPassword,
			&i.SmbShareName,
			&i.SmbPath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFileBackendsByType = `-- name: ListFileBackendsByType :many
SELECT id, type, url, server_host, server_port, need_auth, auth_username, auth_password, smb_share_name, smb_path, created_at, updated_at FROM file_backends 
WHERE type = ? 
ORDER BY created_at DESC
`

// List file backends by type
func (q *Queries) ListFileBackendsByType(ctx context.Context, type_ int64) ([]FileBackend, error) {
	rows, err := q.db.QueryContext(ctx, listFileBackendsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileBackend
	for rows.Next() {
		var i FileBackend
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Url,
			&i.ServerHost,
			&i.ServerPort,
			&i.NeedAuth,
			&i.AuthUsername,
			&i.AuthPassword,
			&i.SmbShareName,
			&i.SmbPath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStores = `-- name: ListStores :many
SELECT id, name, description, file_backend_id, created_at, updated_at FROM stores 
ORDER BY created_at DESC
`

// List all stores
func (q *Queries) ListStores(ctx context.Context) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, listStores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FileBackendID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoresWithBackend = `-- name: ListStoresWithBackend :many
SELECT 
    s.id, s.name, s.description, s.created_at, s.updated_at,
    fb.id as backend_id, fb.type, fb.url, fb.server_host, fb.server_port,
    fb.need_auth, fb.auth_username, fb.auth_password, fb.smb_share_name, fb.smb_path
FROM stores s
JOIN file_backends fb ON s.file_backend_id = fb.id
ORDER BY s.created_at DESC
`

type ListStoresWithBackendRow struct {
	ID           int64
	Name         string
	Description  sql.NullString
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	BackendID    int64
	Type         int64
	Url          string
	ServerHost   sql.NullString
	ServerPort   sql.NullInt64
	NeedAuth     sql.NullBool
	AuthUsername sql.NullString
	AuthPassword sql.NullString
	SmbShareName sql.NullString
	SmbPath      sql.NullString
}

// List stores with file backend information
func (q *Queries) ListStoresWithBackend(ctx context.Context) ([]ListStoresWithBackendRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoresWithBackend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStoresWithBackendRow
	for rows.Next() {
		var i ListStoresWithBackendRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BackendID,
			&i.Type,
			&i.Url,
			&i.ServerHost,
			&i.ServerPort,
			&i.NeedAuth,
			&i.AuthUsername,
			&i.AuthPassword,
			&i.SmbShareName,
			&i.SmbPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBookAsDeleted = `-- name: MarkBookAsDeleted :exec
UPDATE books SET
    deleted = TRUE,
    modified_time = CURRENT_TIMESTAMP
WHERE book_id = ?
`

// Mark book as deleted (soft delete)
func (q *Queries) MarkBookAsDeleted(ctx context.Context, bookID string) error {
	_, err := q.db.ExecContext(ctx, markBookAsDeleted, bookID)
	return err
}

const searchBooksByTitle = `-- name: SearchBooksByTitle :many
SELECT id, title, book_id, owner, file_path, book_store_path, type, child_books_num, child_books_id, depth, parent_folder, page_count, file_size, author, isbn, press, published_at, extract_path, modified_time, extract_num, init_complete, read_percent, non_utf8zip, zip_text_encoding, deleted FROM books 
WHERE title LIKE '%' || ? || '%' 
ORDER BY modified_time DESC
`

// Search books by title (fuzzy search)
func (q *Queries) SearchBooksByTitle(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, searchBooksByTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BookID,
			&i.Owner,
			&i.FilePath,
			&i.BookStorePath,
			&i.Type,
			&i.ChildBooksNum,
			&i.ChildBooksID,
			&i.Depth,
			&i.ParentFolder,
			&i.PageCount,
			&i.FileSize,
			&i.Author,
			&i.Isbn,
			&i.Press,
			&i.PublishedAt,
			&i.ExtractPath,
			&i.ModifiedTime,
			&i.ExtractNum,
			&i.InitComplete,
			&i.ReadPercent,
			&i.NonUtf8zip,
			&i.ZipTextEncoding,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :exec
UPDATE books SET
    title = ?, owner = ?, file_path = ?, book_store_path = ?, type = ?,
    child_books_num = ?, child_books_id = ?, depth = ?, parent_folder = ?, page_count = ?, file_size = ?,
    author = ?, isbn = ?, press = ?, published_at = ?, extract_path = ?, extract_num = ?,
    init_complete = ?, read_percent = ?, non_utf8zip = ?, zip_text_encoding = ?,
    modified_time = CURRENT_TIMESTAMP
WHERE book_id = ?
`

type UpdateBookParams struct {
	Title           string
	Owner           sql.NullString
	FilePath        string
	BookStorePath   string
	Type            string
	ChildBooksNum   sql.NullInt64
	ChildBooksID    sql.NullString
	Depth           sql.NullInt64
	ParentFolder    sql.NullString
	PageCount       sql.NullInt64
	FileSize        sql.NullInt64
	Author          sql.NullString
	Isbn            sql.NullString
	Press           sql.NullString
	PublishedAt     sql.NullString
	ExtractPath     sql.NullString
	ExtractNum      sql.NullInt64
	InitComplete    sql.NullBool
	ReadPercent     sql.NullFloat64
	NonUtf8zip      sql.NullBool
	ZipTextEncoding sql.NullString
	BookID          string
}

// Update book information
func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.ExecContext(ctx, updateBook,
		arg.Title,
		arg.Owner,
		arg.FilePath,
		arg.BookStorePath,
		arg.Type,
		arg.ChildBooksNum,
		arg.ChildBooksID,
		arg.Depth,
		arg.ParentFolder,
		arg.PageCount,
		arg.FileSize,
		arg.Author,
		arg.Isbn,
		arg.Press,
		arg.PublishedAt,
		arg.ExtractPath,
		arg.ExtractNum,
		arg.InitComplete,
		arg.ReadPercent,
		arg.NonUtf8zip,
		arg.ZipTextEncoding,
		arg.BookID,
	)
	return err
}

const updateFileBackend = `-- name: UpdateFileBackend :exec
UPDATE file_backends SET
    type = ?, url = ?, server_host = ?, server_port = ?, need_auth = ?,
    auth_username = ?, auth_password = ?, smb_share_name = ?, smb_path = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateFileBackendParams struct {
	Type         int64
	Url          string
	ServerHost   sql.NullString
	ServerPort   sql.NullInt64
	NeedAuth     sql.NullBool
	AuthUsername sql.NullString
	AuthPassword sql.NullString
	SmbShareName sql.NullString
	SmbPath      sql.NullString
	ID           int64
}

// Update file backend
func (q *Queries) UpdateFileBackend(ctx context.Context, arg UpdateFileBackendParams) error {
	_, err := q.db.ExecContext(ctx, updateFileBackend,
		arg.Type,
		arg.Url,
		arg.ServerHost,
		arg.ServerPort,
		arg.NeedAuth,
		arg.AuthUsername,
		arg.AuthPassword,
		arg.SmbShareName,
		arg.SmbPath,
		arg.ID,
	)
	return err
}

const updateMediaFile = `-- name: UpdateMediaFile :exec
UPDATE media_files SET
    name = ?, path = ?, size = ?, mod_time = ?, url = ?,
    blurhash = ?, height = ?, width = ?, img_type = ?, insert_html = ?
WHERE book_id = ? AND page_num = ?
`

type UpdateMediaFileParams struct {
	Name       string
	Path       sql.NullString
	Size       sql.NullInt64
	ModTime    sql.NullTime
	Url        sql.NullString
	Blurhash   sql.NullString
	Height     sql.NullInt64
	Width      sql.NullInt64
	ImgType    sql.NullString
	InsertHtml sql.NullString
	BookID     string
	PageNum    sql.NullInt64
}

// Update media file information
func (q *Queries) UpdateMediaFile(ctx context.Context, arg UpdateMediaFileParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaFile,
		arg.Name,
		arg.Path,
		arg.Size,
		arg.ModTime,
		arg.Url,
		arg.Blurhash,
		arg.Height,
		arg.Width,
		arg.ImgType,
		arg.InsertHtml,
		arg.BookID,
		arg.PageNum,
	)
	return err
}

const updateReadPercent = `-- name: UpdateReadPercent :exec
UPDATE books SET
    read_percent = ?,
    modified_time = CURRENT_TIMESTAMP
WHERE book_id = ?
`

type UpdateReadPercentParams struct {
	ReadPercent sql.NullFloat64
	BookID      string
}

// Update reading progress
func (q *Queries) UpdateReadPercent(ctx context.Context, arg UpdateReadPercentParams) error {
	_, err := q.db.ExecContext(ctx, updateReadPercent, arg.ReadPercent, arg.BookID)
	return err
}

const updateStore = `-- name: UpdateStore :exec
UPDATE stores SET
    name = ?, description = ?, file_backend_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateStoreParams struct {
	Name          string
	Description   sql.NullString
	FileBackendID int64
	ID            int64
}

// Update store
func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) error {
	_, err := q.db.ExecContext(ctx, updateStore,
		arg.Name,
		arg.Description,
		arg.FileBackendID,
		arg.ID,
	)
	return err
}
