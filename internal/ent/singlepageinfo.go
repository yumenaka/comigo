// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/yumenaka/comigo/internal/ent/singlepageinfo"
)

// SinglePageInfo is the model entity for the SinglePageInfo schema.
type SinglePageInfo struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// BookID holds the value of the "BookID" field.
	BookID string `json:"BookID,omitempty"`
	// PageNum holds the value of the "PageNum" field.
	PageNum int `json:"PageNum,omitempty"`
	// NameInArchive holds the value of the "NameInArchive" field.
	NameInArchive string `json:"NameInArchive,omitempty"`
	// URL holds the value of the "Url" field.
	URL string `json:"Url,omitempty"`
	// BlurHash holds the value of the "BlurHash" field.
	BlurHash string `json:"BlurHash,omitempty"`
	// Height holds the value of the "Height" field.
	Height int `json:"Height,omitempty"`
	// Width holds the value of the "Width" field.
	Width int `json:"Width,omitempty"`
	// ModeTime holds the value of the "ModeTime" field.
	ModeTime time.Time `json:"ModeTime,omitempty"`
	// FileSize holds the value of the "FileSize" field.
	FileSize int64 `json:"FileSize,omitempty"`
	// RealImageFilePATH holds the value of the "RealImageFilePATH" field.
	RealImageFilePATH string `json:"RealImageFilePATH,omitempty"`
	// ImgType holds the value of the "ImgType" field.
	ImgType         string `json:"ImgType,omitempty"`
	book_page_infos *int
	selectValues    sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*SinglePageInfo) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case singlepageinfo.FieldID, singlepageinfo.FieldPageNum, singlepageinfo.FieldHeight, singlepageinfo.FieldWidth, singlepageinfo.FieldFileSize:
			values[i] = new(sql.NullInt64)
		case singlepageinfo.FieldBookID, singlepageinfo.FieldNameInArchive, singlepageinfo.FieldURL, singlepageinfo.FieldBlurHash, singlepageinfo.FieldRealImageFilePATH, singlepageinfo.FieldImgType:
			values[i] = new(sql.NullString)
		case singlepageinfo.FieldModeTime:
			values[i] = new(sql.NullTime)
		case singlepageinfo.ForeignKeys[0]: // book_page_infos
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the SinglePageInfo fields.
func (spi *SinglePageInfo) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case singlepageinfo.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			spi.ID = int(value.Int64)
		case singlepageinfo.FieldBookID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field BookID", values[i])
			} else if value.Valid {
				spi.BookID = value.String
			}
		case singlepageinfo.FieldPageNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field PageNum", values[i])
			} else if value.Valid {
				spi.PageNum = int(value.Int64)
			}
		case singlepageinfo.FieldNameInArchive:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field NameInArchive", values[i])
			} else if value.Valid {
				spi.NameInArchive = value.String
			}
		case singlepageinfo.FieldURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field Url", values[i])
			} else if value.Valid {
				spi.URL = value.String
			}
		case singlepageinfo.FieldBlurHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field BlurHash", values[i])
			} else if value.Valid {
				spi.BlurHash = value.String
			}
		case singlepageinfo.FieldHeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field Height", values[i])
			} else if value.Valid {
				spi.Height = int(value.Int64)
			}
		case singlepageinfo.FieldWidth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field Width", values[i])
			} else if value.Valid {
				spi.Width = int(value.Int64)
			}
		case singlepageinfo.FieldModeTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field ModeTime", values[i])
			} else if value.Valid {
				spi.ModeTime = value.Time
			}
		case singlepageinfo.FieldFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field FileSize", values[i])
			} else if value.Valid {
				spi.FileSize = value.Int64
			}
		case singlepageinfo.FieldRealImageFilePATH:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field RealImageFilePATH", values[i])
			} else if value.Valid {
				spi.RealImageFilePATH = value.String
			}
		case singlepageinfo.FieldImgType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ImgType", values[i])
			} else if value.Valid {
				spi.ImgType = value.String
			}
		case singlepageinfo.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field book_page_infos", value)
			} else if value.Valid {
				spi.book_page_infos = new(int)
				*spi.book_page_infos = int(value.Int64)
			}
		default:
			spi.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the SinglePageInfo.
// This includes values selected through modifiers, order, etc.
func (spi *SinglePageInfo) Value(name string) (ent.Value, error) {
	return spi.selectValues.Get(name)
}

// Update returns a builder for updating this SinglePageInfo.
// Note that you need to call SinglePageInfo.Unwrap() before calling this method if this SinglePageInfo
// was returned from a transaction, and the transaction was committed or rolled back.
func (spi *SinglePageInfo) Update() *SinglePageInfoUpdateOne {
	return NewSinglePageInfoClient(spi.config).UpdateOne(spi)
}

// Unwrap unwraps the SinglePageInfo entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (spi *SinglePageInfo) Unwrap() *SinglePageInfo {
	_tx, ok := spi.config.driver.(*txDriver)
	if !ok {
		panic("ent: SinglePageInfo is not a transactional entity")
	}
	spi.config.driver = _tx.drv
	return spi
}

// String implements the fmt.Stringer.
func (spi *SinglePageInfo) String() string {
	var builder strings.Builder
	builder.WriteString("SinglePageInfo(")
	builder.WriteString(fmt.Sprintf("id=%v, ", spi.ID))
	builder.WriteString("BookID=")
	builder.WriteString(spi.BookID)
	builder.WriteString(", ")
	builder.WriteString("PageNum=")
	builder.WriteString(fmt.Sprintf("%v", spi.PageNum))
	builder.WriteString(", ")
	builder.WriteString("NameInArchive=")
	builder.WriteString(spi.NameInArchive)
	builder.WriteString(", ")
	builder.WriteString("Url=")
	builder.WriteString(spi.URL)
	builder.WriteString(", ")
	builder.WriteString("BlurHash=")
	builder.WriteString(spi.BlurHash)
	builder.WriteString(", ")
	builder.WriteString("Height=")
	builder.WriteString(fmt.Sprintf("%v", spi.Height))
	builder.WriteString(", ")
	builder.WriteString("Width=")
	builder.WriteString(fmt.Sprintf("%v", spi.Width))
	builder.WriteString(", ")
	builder.WriteString("ModeTime=")
	builder.WriteString(spi.ModeTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("FileSize=")
	builder.WriteString(fmt.Sprintf("%v", spi.FileSize))
	builder.WriteString(", ")
	builder.WriteString("RealImageFilePATH=")
	builder.WriteString(spi.RealImageFilePATH)
	builder.WriteString(", ")
	builder.WriteString("ImgType=")
	builder.WriteString(spi.ImgType)
	builder.WriteByte(')')
	return builder.String()
}

// SinglePageInfos is a parsable slice of SinglePageInfo.
type SinglePageInfos []*SinglePageInfo
