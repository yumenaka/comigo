// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/yumenaka/comigo/internal/ent/book"
	"github.com/yumenaka/comigo/internal/ent/predicate"
	"github.com/yumenaka/comigo/internal/ent/singlepageinfo"
	"github.com/yumenaka/comigo/internal/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBook           = "Book"
	TypeSinglePageInfo = "SinglePageInfo"
	TypeUser           = "User"
)

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Title            *string
	_BookID           *string
	_Owner            *string
	_FilePath         *string
	_BookStorePath    *string
	_Type             *string
	_ChildBookNum     *int
	add_ChildBookNum  *int
	_Depth            *int
	add_Depth         *int
	_ParentFolder     *string
	_PageCount        *int
	add_PageCount     *int
	_Size             *int64
	add_Size          *int64
	_Authors          *string
	_ISBN             *string
	_Press            *string
	_PublishedAt      *string
	_ExtractPath      *string
	_Modified         *time.Time
	_ExtractNum       *int
	add_ExtractNum    *int
	_InitComplete     *bool
	_ReadPercent      *float64
	add_ReadPercent   *float64
	_NonUTF8Zip       *bool
	_ZipTextEncoding  *string
	clearedFields     map[string]struct{}
	_PageInfos        map[int]struct{}
	removed_PageInfos map[int]struct{}
	cleared_PageInfos bool
	done              bool
	oldValue          func(context.Context) (*Book, error)
	predicates        []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "Title" field.
func (m *BookMutation) SetTitle(s string) {
	m._Title = &s
}

// Title returns the value of the "Title" field in the mutation.
func (m *BookMutation) Title() (r string, exists bool) {
	v := m._Title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "Title" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "Title" field.
func (m *BookMutation) ResetTitle() {
	m._Title = nil
}

// SetBookID sets the "BookID" field.
func (m *BookMutation) SetBookID(s string) {
	m._BookID = &s
}

// BookID returns the value of the "BookID" field in the mutation.
func (m *BookMutation) BookID() (r string, exists bool) {
	v := m._BookID
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "BookID" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldBookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// ResetBookID resets all changes to the "BookID" field.
func (m *BookMutation) ResetBookID() {
	m._BookID = nil
}

// SetOwner sets the "Owner" field.
func (m *BookMutation) SetOwner(s string) {
	m._Owner = &s
}

// Owner returns the value of the "Owner" field in the mutation.
func (m *BookMutation) Owner() (r string, exists bool) {
	v := m._Owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "Owner" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "Owner" field.
func (m *BookMutation) ResetOwner() {
	m._Owner = nil
}

// SetFilePath sets the "FilePath" field.
func (m *BookMutation) SetFilePath(s string) {
	m._FilePath = &s
}

// FilePath returns the value of the "FilePath" field in the mutation.
func (m *BookMutation) FilePath() (r string, exists bool) {
	v := m._FilePath
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "FilePath" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "FilePath" field.
func (m *BookMutation) ResetFilePath() {
	m._FilePath = nil
}

// SetBookStorePath sets the "BookStorePath" field.
func (m *BookMutation) SetBookStorePath(s string) {
	m._BookStorePath = &s
}

// BookStorePath returns the value of the "BookStorePath" field in the mutation.
func (m *BookMutation) BookStorePath() (r string, exists bool) {
	v := m._BookStorePath
	if v == nil {
		return
	}
	return *v, true
}

// OldBookStorePath returns the old "BookStorePath" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldBookStorePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookStorePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookStorePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookStorePath: %w", err)
	}
	return oldValue.BookStorePath, nil
}

// ResetBookStorePath resets all changes to the "BookStorePath" field.
func (m *BookMutation) ResetBookStorePath() {
	m._BookStorePath = nil
}

// SetType sets the "Type" field.
func (m *BookMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *BookMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *BookMutation) ResetType() {
	m._Type = nil
}

// SetChildBookNum sets the "ChildBooksNum" field.
func (m *BookMutation) SetChildBookNum(i int) {
	m._ChildBookNum = &i
	m.add_ChildBookNum = nil
}

// ChildBooksNum returns the value of the "ChildBooksNum" field in the mutation.
func (m *BookMutation) ChildBooksNum() (r int, exists bool) {
	v := m._ChildBookNum
	if v == nil {
		return
	}
	return *v, true
}

// OldChildBookNum returns the old "ChildBooksNum" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldChildBookNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildBookNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildBookNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildBookNum: %w", err)
	}
	return oldValue.ChildBooksNum, nil
}

// AddChildBookNum adds i to the "ChildBooksNum" field.
func (m *BookMutation) AddChildBookNum(i int) {
	if m.add_ChildBookNum != nil {
		*m.add_ChildBookNum += i
	} else {
		m.add_ChildBookNum = &i
	}
}

// AddedChildBookNum returns the value that was added to the "ChildBooksNum" field in this mutation.
func (m *BookMutation) AddedChildBookNum() (r int, exists bool) {
	v := m.add_ChildBookNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildBookNum resets all changes to the "ChildBooksNum" field.
func (m *BookMutation) ResetChildBookNum() {
	m._ChildBookNum = nil
	m.add_ChildBookNum = nil
}

// SetDepth sets the "Depth" field.
func (m *BookMutation) SetDepth(i int) {
	m._Depth = &i
	m.add_Depth = nil
}

// Depth returns the value of the "Depth" field in the mutation.
func (m *BookMutation) Depth() (r int, exists bool) {
	v := m._Depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "Depth" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldDepth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds i to the "Depth" field.
func (m *BookMutation) AddDepth(i int) {
	if m.add_Depth != nil {
		*m.add_Depth += i
	} else {
		m.add_Depth = &i
	}
}

// AddedDepth returns the value that was added to the "Depth" field in this mutation.
func (m *BookMutation) AddedDepth() (r int, exists bool) {
	v := m.add_Depth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "Depth" field.
func (m *BookMutation) ResetDepth() {
	m._Depth = nil
	m.add_Depth = nil
}

// SetParentFolder sets the "ParentFolder" field.
func (m *BookMutation) SetParentFolder(s string) {
	m._ParentFolder = &s
}

// ParentFolder returns the value of the "ParentFolder" field in the mutation.
func (m *BookMutation) ParentFolder() (r string, exists bool) {
	v := m._ParentFolder
	if v == nil {
		return
	}
	return *v, true
}

// OldParentFolder returns the old "ParentFolder" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldParentFolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentFolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentFolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentFolder: %w", err)
	}
	return oldValue.ParentFolder, nil
}

// ResetParentFolder resets all changes to the "ParentFolder" field.
func (m *BookMutation) ResetParentFolder() {
	m._ParentFolder = nil
}

// SetPageCount sets the "PageCount" field.
func (m *BookMutation) SetPageCount(i int) {
	m._PageCount = &i
	m.add_PageCount = nil
}

// PageCount returns the value of the "PageCount" field in the mutation.
func (m *BookMutation) PageCount() (r int, exists bool) {
	v := m._PageCount
	if v == nil {
		return
	}
	return *v, true
}

// OldPageCount returns the old "PageCount" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageCount: %w", err)
	}
	return oldValue.PageCount, nil
}

// AddPageCount adds i to the "PageCount" field.
func (m *BookMutation) AddPageCount(i int) {
	if m.add_PageCount != nil {
		*m.add_PageCount += i
	} else {
		m.add_PageCount = &i
	}
}

// AddedPageCount returns the value that was added to the "PageCount" field in this mutation.
func (m *BookMutation) AddedPageCount() (r int, exists bool) {
	v := m.add_PageCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageCount resets all changes to the "PageCount" field.
func (m *BookMutation) ResetPageCount() {
	m._PageCount = nil
	m.add_PageCount = nil
}

// SetSize sets the "Size" field.
func (m *BookMutation) SetSize(i int64) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *BookMutation) Size() (r int64, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *BookMutation) AddSize(i int64) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *BookMutation) AddedSize() (r int64, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *BookMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetAuthors sets the "Authors" field.
func (m *BookMutation) SetAuthors(s string) {
	m._Authors = &s
}

// Authors returns the value of the "Authors" field in the mutation.
func (m *BookMutation) Authors() (r string, exists bool) {
	v := m._Authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "Authors" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAuthors(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// ResetAuthors resets all changes to the "Authors" field.
func (m *BookMutation) ResetAuthors() {
	m._Authors = nil
}

// SetISBN sets the "ISBN" field.
func (m *BookMutation) SetISBN(s string) {
	m._ISBN = &s
}

// ISBN returns the value of the "ISBN" field in the mutation.
func (m *BookMutation) ISBN() (r string, exists bool) {
	v := m._ISBN
	if v == nil {
		return
	}
	return *v, true
}

// OldISBN returns the old "ISBN" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldISBN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldISBN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldISBN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldISBN: %w", err)
	}
	return oldValue.ISBN, nil
}

// ResetISBN resets all changes to the "ISBN" field.
func (m *BookMutation) ResetISBN() {
	m._ISBN = nil
}

// SetPress sets the "Press" field.
func (m *BookMutation) SetPress(s string) {
	m._Press = &s
}

// Press returns the value of the "Press" field in the mutation.
func (m *BookMutation) Press() (r string, exists bool) {
	v := m._Press
	if v == nil {
		return
	}
	return *v, true
}

// OldPress returns the old "Press" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPress: %w", err)
	}
	return oldValue.Press, nil
}

// ResetPress resets all changes to the "Press" field.
func (m *BookMutation) ResetPress() {
	m._Press = nil
}

// SetPublishedAt sets the "PublishedAt" field.
func (m *BookMutation) SetPublishedAt(s string) {
	m._PublishedAt = &s
}

// PublishedAt returns the value of the "PublishedAt" field in the mutation.
func (m *BookMutation) PublishedAt() (r string, exists bool) {
	v := m._PublishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "PublishedAt" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublishedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ResetPublishedAt resets all changes to the "PublishedAt" field.
func (m *BookMutation) ResetPublishedAt() {
	m._PublishedAt = nil
}

// SetExtractPath sets the "ExtractPath" field.
func (m *BookMutation) SetExtractPath(s string) {
	m._ExtractPath = &s
}

// ExtractPath returns the value of the "ExtractPath" field in the mutation.
func (m *BookMutation) ExtractPath() (r string, exists bool) {
	v := m._ExtractPath
	if v == nil {
		return
	}
	return *v, true
}

// OldExtractPath returns the old "ExtractPath" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldExtractPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtractPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtractPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtractPath: %w", err)
	}
	return oldValue.ExtractPath, nil
}

// ResetExtractPath resets all changes to the "ExtractPath" field.
func (m *BookMutation) ResetExtractPath() {
	m._ExtractPath = nil
}

// SetModified sets the "Modified" field.
func (m *BookMutation) SetModified(t time.Time) {
	m._Modified = &t
}

// Modified returns the value of the "Modified" field in the mutation.
func (m *BookMutation) Modified() (r time.Time, exists bool) {
	v := m._Modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "Modified" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "Modified" field.
func (m *BookMutation) ResetModified() {
	m._Modified = nil
}

// SetExtractNum sets the "ExtractNum" field.
func (m *BookMutation) SetExtractNum(i int) {
	m._ExtractNum = &i
	m.add_ExtractNum = nil
}

// ExtractNum returns the value of the "ExtractNum" field in the mutation.
func (m *BookMutation) ExtractNum() (r int, exists bool) {
	v := m._ExtractNum
	if v == nil {
		return
	}
	return *v, true
}

// OldExtractNum returns the old "ExtractNum" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldExtractNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtractNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtractNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtractNum: %w", err)
	}
	return oldValue.ExtractNum, nil
}

// AddExtractNum adds i to the "ExtractNum" field.
func (m *BookMutation) AddExtractNum(i int) {
	if m.add_ExtractNum != nil {
		*m.add_ExtractNum += i
	} else {
		m.add_ExtractNum = &i
	}
}

// AddedExtractNum returns the value that was added to the "ExtractNum" field in this mutation.
func (m *BookMutation) AddedExtractNum() (r int, exists bool) {
	v := m.add_ExtractNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtractNum resets all changes to the "ExtractNum" field.
func (m *BookMutation) ResetExtractNum() {
	m._ExtractNum = nil
	m.add_ExtractNum = nil
}

// SetInitComplete sets the "InitComplete" field.
func (m *BookMutation) SetInitComplete(b bool) {
	m._InitComplete = &b
}

// InitComplete returns the value of the "InitComplete" field in the mutation.
func (m *BookMutation) InitComplete() (r bool, exists bool) {
	v := m._InitComplete
	if v == nil {
		return
	}
	return *v, true
}

// OldInitComplete returns the old "InitComplete" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldInitComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitComplete: %w", err)
	}
	return oldValue.InitComplete, nil
}

// ResetInitComplete resets all changes to the "InitComplete" field.
func (m *BookMutation) ResetInitComplete() {
	m._InitComplete = nil
}

// SetReadPercent sets the "ReadPercent" field.
func (m *BookMutation) SetReadPercent(f float64) {
	m._ReadPercent = &f
	m.add_ReadPercent = nil
}

// ReadPercent returns the value of the "ReadPercent" field in the mutation.
func (m *BookMutation) ReadPercent() (r float64, exists bool) {
	v := m._ReadPercent
	if v == nil {
		return
	}
	return *v, true
}

// OldReadPercent returns the old "ReadPercent" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldReadPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadPercent: %w", err)
	}
	return oldValue.ReadPercent, nil
}

// AddReadPercent adds f to the "ReadPercent" field.
func (m *BookMutation) AddReadPercent(f float64) {
	if m.add_ReadPercent != nil {
		*m.add_ReadPercent += f
	} else {
		m.add_ReadPercent = &f
	}
}

// AddedReadPercent returns the value that was added to the "ReadPercent" field in this mutation.
func (m *BookMutation) AddedReadPercent() (r float64, exists bool) {
	v := m.add_ReadPercent
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadPercent resets all changes to the "ReadPercent" field.
func (m *BookMutation) ResetReadPercent() {
	m._ReadPercent = nil
	m.add_ReadPercent = nil
}

// SetNonUTF8Zip sets the "NonUTF8Zip" field.
func (m *BookMutation) SetNonUTF8Zip(b bool) {
	m._NonUTF8Zip = &b
}

// NonUTF8Zip returns the value of the "NonUTF8Zip" field in the mutation.
func (m *BookMutation) NonUTF8Zip() (r bool, exists bool) {
	v := m._NonUTF8Zip
	if v == nil {
		return
	}
	return *v, true
}

// OldNonUTF8Zip returns the old "NonUTF8Zip" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldNonUTF8Zip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonUTF8Zip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonUTF8Zip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonUTF8Zip: %w", err)
	}
	return oldValue.NonUTF8Zip, nil
}

// ResetNonUTF8Zip resets all changes to the "NonUTF8Zip" field.
func (m *BookMutation) ResetNonUTF8Zip() {
	m._NonUTF8Zip = nil
}

// SetZipTextEncoding sets the "ZipTextEncoding" field.
func (m *BookMutation) SetZipTextEncoding(s string) {
	m._ZipTextEncoding = &s
}

// ZipTextEncoding returns the value of the "ZipTextEncoding" field in the mutation.
func (m *BookMutation) ZipTextEncoding() (r string, exists bool) {
	v := m._ZipTextEncoding
	if v == nil {
		return
	}
	return *v, true
}

// OldZipTextEncoding returns the old "ZipTextEncoding" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldZipTextEncoding(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipTextEncoding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipTextEncoding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipTextEncoding: %w", err)
	}
	return oldValue.ZipTextEncoding, nil
}

// ResetZipTextEncoding resets all changes to the "ZipTextEncoding" field.
func (m *BookMutation) ResetZipTextEncoding() {
	m._ZipTextEncoding = nil
}

// AddPageInfoIDs adds the "PageInfos" edge to the SinglePageInfo entity by ids.
func (m *BookMutation) AddPageInfoIDs(ids ...int) {
	if m._PageInfos == nil {
		m._PageInfos = make(map[int]struct{})
	}
	for i := range ids {
		m._PageInfos[ids[i]] = struct{}{}
	}
}

// ClearPageInfos clears the "PageInfos" edge to the SinglePageInfo entity.
func (m *BookMutation) ClearPageInfos() {
	m.cleared_PageInfos = true
}

// PageInfosCleared reports if the "PageInfos" edge to the SinglePageInfo entity was cleared.
func (m *BookMutation) PageInfosCleared() bool {
	return m.cleared_PageInfos
}

// RemovePageInfoIDs removes the "PageInfos" edge to the SinglePageInfo entity by IDs.
func (m *BookMutation) RemovePageInfoIDs(ids ...int) {
	if m.removed_PageInfos == nil {
		m.removed_PageInfos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._PageInfos, ids[i])
		m.removed_PageInfos[ids[i]] = struct{}{}
	}
}

// RemovedPageInfos returns the removed IDs of the "PageInfos" edge to the SinglePageInfo entity.
func (m *BookMutation) RemovedPageInfosIDs() (ids []int) {
	for id := range m.removed_PageInfos {
		ids = append(ids, id)
	}
	return
}

// PageInfosIDs returns the "PageInfos" edge IDs in the mutation.
func (m *BookMutation) PageInfosIDs() (ids []int) {
	for id := range m._PageInfos {
		ids = append(ids, id)
	}
	return
}

// ResetPageInfos resets all changes to the "PageInfos" edge.
func (m *BookMutation) ResetPageInfos() {
	m._PageInfos = nil
	m.cleared_PageInfos = false
	m.removed_PageInfos = nil
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m._Title != nil {
		fields = append(fields, book.FieldTitle)
	}
	if m._BookID != nil {
		fields = append(fields, book.FieldBookID)
	}
	if m._Owner != nil {
		fields = append(fields, book.FieldOwner)
	}
	if m._FilePath != nil {
		fields = append(fields, book.FieldFilePath)
	}
	if m._BookStorePath != nil {
		fields = append(fields, book.FieldBookStorePath)
	}
	if m._Type != nil {
		fields = append(fields, book.FieldType)
	}
	if m._ChildBookNum != nil {
		fields = append(fields, book.FieldChildBookNum)
	}
	if m._Depth != nil {
		fields = append(fields, book.FieldDepth)
	}
	if m._ParentFolder != nil {
		fields = append(fields, book.FieldParentFolder)
	}
	if m._PageCount != nil {
		fields = append(fields, book.FieldPageCount)
	}
	if m._Size != nil {
		fields = append(fields, book.FieldSize)
	}
	if m._Authors != nil {
		fields = append(fields, book.FieldAuthors)
	}
	if m._ISBN != nil {
		fields = append(fields, book.FieldISBN)
	}
	if m._Press != nil {
		fields = append(fields, book.FieldPress)
	}
	if m._PublishedAt != nil {
		fields = append(fields, book.FieldPublishedAt)
	}
	if m._ExtractPath != nil {
		fields = append(fields, book.FieldExtractPath)
	}
	if m._Modified != nil {
		fields = append(fields, book.FieldModified)
	}
	if m._ExtractNum != nil {
		fields = append(fields, book.FieldExtractNum)
	}
	if m._InitComplete != nil {
		fields = append(fields, book.FieldInitComplete)
	}
	if m._ReadPercent != nil {
		fields = append(fields, book.FieldReadPercent)
	}
	if m._NonUTF8Zip != nil {
		fields = append(fields, book.FieldNonUTF8Zip)
	}
	if m._ZipTextEncoding != nil {
		fields = append(fields, book.FieldZipTextEncoding)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldTitle:
		return m.Title()
	case book.FieldBookID:
		return m.BookID()
	case book.FieldOwner:
		return m.Owner()
	case book.FieldFilePath:
		return m.FilePath()
	case book.FieldBookStorePath:
		return m.BookStorePath()
	case book.FieldType:
		return m.GetType()
	case book.FieldChildBookNum:
		return m.ChildBooksNum()
	case book.FieldDepth:
		return m.Depth()
	case book.FieldParentFolder:
		return m.ParentFolder()
	case book.FieldPageCount:
		return m.PageCount()
	case book.FieldSize:
		return m.Size()
	case book.FieldAuthors:
		return m.Authors()
	case book.FieldISBN:
		return m.ISBN()
	case book.FieldPress:
		return m.Press()
	case book.FieldPublishedAt:
		return m.PublishedAt()
	case book.FieldExtractPath:
		return m.ExtractPath()
	case book.FieldModified:
		return m.Modified()
	case book.FieldExtractNum:
		return m.ExtractNum()
	case book.FieldInitComplete:
		return m.InitComplete()
	case book.FieldReadPercent:
		return m.ReadPercent()
	case book.FieldNonUTF8Zip:
		return m.NonUTF8Zip()
	case book.FieldZipTextEncoding:
		return m.ZipTextEncoding()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldTitle:
		return m.OldTitle(ctx)
	case book.FieldBookID:
		return m.OldBookID(ctx)
	case book.FieldOwner:
		return m.OldOwner(ctx)
	case book.FieldFilePath:
		return m.OldFilePath(ctx)
	case book.FieldBookStorePath:
		return m.OldBookStorePath(ctx)
	case book.FieldType:
		return m.OldType(ctx)
	case book.FieldChildBookNum:
		return m.OldChildBookNum(ctx)
	case book.FieldDepth:
		return m.OldDepth(ctx)
	case book.FieldParentFolder:
		return m.OldParentFolder(ctx)
	case book.FieldPageCount:
		return m.OldPageCount(ctx)
	case book.FieldSize:
		return m.OldSize(ctx)
	case book.FieldAuthors:
		return m.OldAuthors(ctx)
	case book.FieldISBN:
		return m.OldISBN(ctx)
	case book.FieldPress:
		return m.OldPress(ctx)
	case book.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case book.FieldExtractPath:
		return m.OldExtractPath(ctx)
	case book.FieldModified:
		return m.OldModified(ctx)
	case book.FieldExtractNum:
		return m.OldExtractNum(ctx)
	case book.FieldInitComplete:
		return m.OldInitComplete(ctx)
	case book.FieldReadPercent:
		return m.OldReadPercent(ctx)
	case book.FieldNonUTF8Zip:
		return m.OldNonUTF8Zip(ctx)
	case book.FieldZipTextEncoding:
		return m.OldZipTextEncoding(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case book.FieldBookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	case book.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case book.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case book.FieldBookStorePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookStorePath(v)
		return nil
	case book.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case book.FieldChildBookNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildBookNum(v)
		return nil
	case book.FieldDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case book.FieldParentFolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentFolder(v)
		return nil
	case book.FieldPageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageCount(v)
		return nil
	case book.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case book.FieldAuthors:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case book.FieldISBN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetISBN(v)
		return nil
	case book.FieldPress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPress(v)
		return nil
	case book.FieldPublishedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case book.FieldExtractPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtractPath(v)
		return nil
	case book.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	case book.FieldExtractNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtractNum(v)
		return nil
	case book.FieldInitComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitComplete(v)
		return nil
	case book.FieldReadPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadPercent(v)
		return nil
	case book.FieldNonUTF8Zip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonUTF8Zip(v)
		return nil
	case book.FieldZipTextEncoding:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipTextEncoding(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	var fields []string
	if m.add_ChildBookNum != nil {
		fields = append(fields, book.FieldChildBookNum)
	}
	if m.add_Depth != nil {
		fields = append(fields, book.FieldDepth)
	}
	if m.add_PageCount != nil {
		fields = append(fields, book.FieldPageCount)
	}
	if m.add_Size != nil {
		fields = append(fields, book.FieldSize)
	}
	if m.add_ExtractNum != nil {
		fields = append(fields, book.FieldExtractNum)
	}
	if m.add_ReadPercent != nil {
		fields = append(fields, book.FieldReadPercent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case book.FieldChildBookNum:
		return m.AddedChildBookNum()
	case book.FieldDepth:
		return m.AddedDepth()
	case book.FieldPageCount:
		return m.AddedPageCount()
	case book.FieldSize:
		return m.AddedSize()
	case book.FieldExtractNum:
		return m.AddedExtractNum()
	case book.FieldReadPercent:
		return m.AddedReadPercent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case book.FieldChildBookNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildBookNum(v)
		return nil
	case book.FieldDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case book.FieldPageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageCount(v)
		return nil
	case book.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case book.FieldExtractNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtractNum(v)
		return nil
	case book.FieldReadPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadPercent(v)
		return nil
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldTitle:
		m.ResetTitle()
		return nil
	case book.FieldBookID:
		m.ResetBookID()
		return nil
	case book.FieldOwner:
		m.ResetOwner()
		return nil
	case book.FieldFilePath:
		m.ResetFilePath()
		return nil
	case book.FieldBookStorePath:
		m.ResetBookStorePath()
		return nil
	case book.FieldType:
		m.ResetType()
		return nil
	case book.FieldChildBookNum:
		m.ResetChildBookNum()
		return nil
	case book.FieldDepth:
		m.ResetDepth()
		return nil
	case book.FieldParentFolder:
		m.ResetParentFolder()
		return nil
	case book.FieldPageCount:
		m.ResetPageCount()
		return nil
	case book.FieldSize:
		m.ResetSize()
		return nil
	case book.FieldAuthors:
		m.ResetAuthors()
		return nil
	case book.FieldISBN:
		m.ResetISBN()
		return nil
	case book.FieldPress:
		m.ResetPress()
		return nil
	case book.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case book.FieldExtractPath:
		m.ResetExtractPath()
		return nil
	case book.FieldModified:
		m.ResetModified()
		return nil
	case book.FieldExtractNum:
		m.ResetExtractNum()
		return nil
	case book.FieldInitComplete:
		m.ResetInitComplete()
		return nil
	case book.FieldReadPercent:
		m.ResetReadPercent()
		return nil
	case book.FieldNonUTF8Zip:
		m.ResetNonUTF8Zip()
		return nil
	case book.FieldZipTextEncoding:
		m.ResetZipTextEncoding()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._PageInfos != nil {
		edges = append(edges, book.EdgePageInfos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgePageInfos:
		ids := make([]ent.Value, 0, len(m._PageInfos))
		for id := range m._PageInfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_PageInfos != nil {
		edges = append(edges, book.EdgePageInfos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgePageInfos:
		ids := make([]ent.Value, 0, len(m.removed_PageInfos))
		for id := range m.removed_PageInfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_PageInfos {
		edges = append(edges, book.EdgePageInfos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	case book.EdgePageInfos:
		return m.cleared_PageInfos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgePageInfos:
		m.ResetPageInfos()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// SinglePageInfoMutation represents an operation that mutates the SinglePageInfo nodes in the graph.
type SinglePageInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_BookID       *string
	_PageNum      *int
	add_PageNum   *int
	_Path         *string
	_Name         *string
	_Url          *string
	_BlurHash     *string
	_Height       *int
	add_Height    *int
	_Width        *int
	add_Width     *int
	_ModTime      *time.Time
	_Size         *int64
	add_Size      *int64
	_ImgType      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SinglePageInfo, error)
	predicates    []predicate.SinglePageInfo
}

var _ ent.Mutation = (*SinglePageInfoMutation)(nil)

// singlepageinfoOption allows management of the mutation configuration using functional options.
type singlepageinfoOption func(*SinglePageInfoMutation)

// newSinglePageInfoMutation creates new mutation for the SinglePageInfo entity.
func newSinglePageInfoMutation(c config, op Op, opts ...singlepageinfoOption) *SinglePageInfoMutation {
	m := &SinglePageInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeSinglePageInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSinglePageInfoID sets the ID field of the mutation.
func withSinglePageInfoID(id int) singlepageinfoOption {
	return func(m *SinglePageInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *SinglePageInfo
		)
		m.oldValue = func(ctx context.Context) (*SinglePageInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SinglePageInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSinglePageInfo sets the old SinglePageInfo of the mutation.
func withSinglePageInfo(node *SinglePageInfo) singlepageinfoOption {
	return func(m *SinglePageInfoMutation) {
		m.oldValue = func(context.Context) (*SinglePageInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SinglePageInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SinglePageInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SinglePageInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SinglePageInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SinglePageInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBookID sets the "BookID" field.
func (m *SinglePageInfoMutation) SetBookID(s string) {
	m._BookID = &s
}

// BookID returns the value of the "BookID" field in the mutation.
func (m *SinglePageInfoMutation) BookID() (r string, exists bool) {
	v := m._BookID
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "BookID" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldBookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// ResetBookID resets all changes to the "BookID" field.
func (m *SinglePageInfoMutation) ResetBookID() {
	m._BookID = nil
}

// SetPageNum sets the "PageNum" field.
func (m *SinglePageInfoMutation) SetPageNum(i int) {
	m._PageNum = &i
	m.add_PageNum = nil
}

// PageNum returns the value of the "PageNum" field in the mutation.
func (m *SinglePageInfoMutation) PageNum() (r int, exists bool) {
	v := m._PageNum
	if v == nil {
		return
	}
	return *v, true
}

// OldPageNum returns the old "PageNum" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldPageNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageNum: %w", err)
	}
	return oldValue.PageNum, nil
}

// AddPageNum adds i to the "PageNum" field.
func (m *SinglePageInfoMutation) AddPageNum(i int) {
	if m.add_PageNum != nil {
		*m.add_PageNum += i
	} else {
		m.add_PageNum = &i
	}
}

// AddedPageNum returns the value that was added to the "PageNum" field in this mutation.
func (m *SinglePageInfoMutation) AddedPageNum() (r int, exists bool) {
	v := m.add_PageNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageNum resets all changes to the "PageNum" field.
func (m *SinglePageInfoMutation) ResetPageNum() {
	m._PageNum = nil
	m.add_PageNum = nil
}

// SetPath sets the "Path" field.
func (m *SinglePageInfoMutation) SetPath(s string) {
	m._Path = &s
}

// Path returns the value of the "Path" field in the mutation.
func (m *SinglePageInfoMutation) Path() (r string, exists bool) {
	v := m._Path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "Path" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "Path" field.
func (m *SinglePageInfoMutation) ResetPath() {
	m._Path = nil
}

// SetName sets the "Name" field.
func (m *SinglePageInfoMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *SinglePageInfoMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *SinglePageInfoMutation) ResetName() {
	m._Name = nil
}

// SetURL sets the "Url" field.
func (m *SinglePageInfoMutation) SetURL(s string) {
	m._Url = &s
}

// URL returns the value of the "Url" field in the mutation.
func (m *SinglePageInfoMutation) URL() (r string, exists bool) {
	v := m._Url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "Url" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "Url" field.
func (m *SinglePageInfoMutation) ResetURL() {
	m._Url = nil
}

// SetBlurHash sets the "BlurHash" field.
func (m *SinglePageInfoMutation) SetBlurHash(s string) {
	m._BlurHash = &s
}

// BlurHash returns the value of the "BlurHash" field in the mutation.
func (m *SinglePageInfoMutation) BlurHash() (r string, exists bool) {
	v := m._BlurHash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlurHash returns the old "BlurHash" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldBlurHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlurHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlurHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlurHash: %w", err)
	}
	return oldValue.BlurHash, nil
}

// ResetBlurHash resets all changes to the "BlurHash" field.
func (m *SinglePageInfoMutation) ResetBlurHash() {
	m._BlurHash = nil
}

// SetHeight sets the "Height" field.
func (m *SinglePageInfoMutation) SetHeight(i int) {
	m._Height = &i
	m.add_Height = nil
}

// Height returns the value of the "Height" field in the mutation.
func (m *SinglePageInfoMutation) Height() (r int, exists bool) {
	v := m._Height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "Height" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "Height" field.
func (m *SinglePageInfoMutation) AddHeight(i int) {
	if m.add_Height != nil {
		*m.add_Height += i
	} else {
		m.add_Height = &i
	}
}

// AddedHeight returns the value that was added to the "Height" field in this mutation.
func (m *SinglePageInfoMutation) AddedHeight() (r int, exists bool) {
	v := m.add_Height
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "Height" field.
func (m *SinglePageInfoMutation) ResetHeight() {
	m._Height = nil
	m.add_Height = nil
}

// SetWidth sets the "Width" field.
func (m *SinglePageInfoMutation) SetWidth(i int) {
	m._Width = &i
	m.add_Width = nil
}

// Width returns the value of the "Width" field in the mutation.
func (m *SinglePageInfoMutation) Width() (r int, exists bool) {
	v := m._Width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "Width" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "Width" field.
func (m *SinglePageInfoMutation) AddWidth(i int) {
	if m.add_Width != nil {
		*m.add_Width += i
	} else {
		m.add_Width = &i
	}
}

// AddedWidth returns the value that was added to the "Width" field in this mutation.
func (m *SinglePageInfoMutation) AddedWidth() (r int, exists bool) {
	v := m.add_Width
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "Width" field.
func (m *SinglePageInfoMutation) ResetWidth() {
	m._Width = nil
	m.add_Width = nil
}

// SetModTime sets the "ModTime" field.
func (m *SinglePageInfoMutation) SetModTime(t time.Time) {
	m._ModTime = &t
}

// ModTime returns the value of the "ModTime" field in the mutation.
func (m *SinglePageInfoMutation) ModTime() (r time.Time, exists bool) {
	v := m._ModTime
	if v == nil {
		return
	}
	return *v, true
}

// OldModTime returns the old "ModTime" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldModTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModTime: %w", err)
	}
	return oldValue.ModTime, nil
}

// ResetModTime resets all changes to the "ModTime" field.
func (m *SinglePageInfoMutation) ResetModTime() {
	m._ModTime = nil
}

// SetSize sets the "Size" field.
func (m *SinglePageInfoMutation) SetSize(i int64) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *SinglePageInfoMutation) Size() (r int64, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *SinglePageInfoMutation) AddSize(i int64) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *SinglePageInfoMutation) AddedSize() (r int64, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *SinglePageInfoMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetImgType sets the "ImgType" field.
func (m *SinglePageInfoMutation) SetImgType(s string) {
	m._ImgType = &s
}

// ImgType returns the value of the "ImgType" field in the mutation.
func (m *SinglePageInfoMutation) ImgType() (r string, exists bool) {
	v := m._ImgType
	if v == nil {
		return
	}
	return *v, true
}

// OldImgType returns the old "ImgType" field's value of the SinglePageInfo entity.
// If the SinglePageInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SinglePageInfoMutation) OldImgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgType: %w", err)
	}
	return oldValue.ImgType, nil
}

// ResetImgType resets all changes to the "ImgType" field.
func (m *SinglePageInfoMutation) ResetImgType() {
	m._ImgType = nil
}

// Where appends a list predicates to the SinglePageInfoMutation builder.
func (m *SinglePageInfoMutation) Where(ps ...predicate.SinglePageInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SinglePageInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SinglePageInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SinglePageInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SinglePageInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SinglePageInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SinglePageInfo).
func (m *SinglePageInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SinglePageInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._BookID != nil {
		fields = append(fields, singlepageinfo.FieldBookID)
	}
	if m._PageNum != nil {
		fields = append(fields, singlepageinfo.FieldPageNum)
	}
	if m._Path != nil {
		fields = append(fields, singlepageinfo.FieldPath)
	}
	if m._Name != nil {
		fields = append(fields, singlepageinfo.FieldName)
	}
	if m._Url != nil {
		fields = append(fields, singlepageinfo.FieldURL)
	}
	if m._BlurHash != nil {
		fields = append(fields, singlepageinfo.FieldBlurHash)
	}
	if m._Height != nil {
		fields = append(fields, singlepageinfo.FieldHeight)
	}
	if m._Width != nil {
		fields = append(fields, singlepageinfo.FieldWidth)
	}
	if m._ModTime != nil {
		fields = append(fields, singlepageinfo.FieldModTime)
	}
	if m._Size != nil {
		fields = append(fields, singlepageinfo.FieldSize)
	}
	if m._ImgType != nil {
		fields = append(fields, singlepageinfo.FieldImgType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SinglePageInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case singlepageinfo.FieldBookID:
		return m.BookID()
	case singlepageinfo.FieldPageNum:
		return m.PageNum()
	case singlepageinfo.FieldPath:
		return m.Path()
	case singlepageinfo.FieldName:
		return m.Name()
	case singlepageinfo.FieldURL:
		return m.URL()
	case singlepageinfo.FieldBlurHash:
		return m.BlurHash()
	case singlepageinfo.FieldHeight:
		return m.Height()
	case singlepageinfo.FieldWidth:
		return m.Width()
	case singlepageinfo.FieldModTime:
		return m.ModTime()
	case singlepageinfo.FieldSize:
		return m.Size()
	case singlepageinfo.FieldImgType:
		return m.ImgType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SinglePageInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case singlepageinfo.FieldBookID:
		return m.OldBookID(ctx)
	case singlepageinfo.FieldPageNum:
		return m.OldPageNum(ctx)
	case singlepageinfo.FieldPath:
		return m.OldPath(ctx)
	case singlepageinfo.FieldName:
		return m.OldName(ctx)
	case singlepageinfo.FieldURL:
		return m.OldURL(ctx)
	case singlepageinfo.FieldBlurHash:
		return m.OldBlurHash(ctx)
	case singlepageinfo.FieldHeight:
		return m.OldHeight(ctx)
	case singlepageinfo.FieldWidth:
		return m.OldWidth(ctx)
	case singlepageinfo.FieldModTime:
		return m.OldModTime(ctx)
	case singlepageinfo.FieldSize:
		return m.OldSize(ctx)
	case singlepageinfo.FieldImgType:
		return m.OldImgType(ctx)
	}
	return nil, fmt.Errorf("unknown SinglePageInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SinglePageInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case singlepageinfo.FieldBookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	case singlepageinfo.FieldPageNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageNum(v)
		return nil
	case singlepageinfo.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case singlepageinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case singlepageinfo.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case singlepageinfo.FieldBlurHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlurHash(v)
		return nil
	case singlepageinfo.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case singlepageinfo.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case singlepageinfo.FieldModTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModTime(v)
		return nil
	case singlepageinfo.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case singlepageinfo.FieldImgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgType(v)
		return nil
	}
	return fmt.Errorf("unknown SinglePageInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SinglePageInfoMutation) AddedFields() []string {
	var fields []string
	if m.add_PageNum != nil {
		fields = append(fields, singlepageinfo.FieldPageNum)
	}
	if m.add_Height != nil {
		fields = append(fields, singlepageinfo.FieldHeight)
	}
	if m.add_Width != nil {
		fields = append(fields, singlepageinfo.FieldWidth)
	}
	if m.add_Size != nil {
		fields = append(fields, singlepageinfo.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SinglePageInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case singlepageinfo.FieldPageNum:
		return m.AddedPageNum()
	case singlepageinfo.FieldHeight:
		return m.AddedHeight()
	case singlepageinfo.FieldWidth:
		return m.AddedWidth()
	case singlepageinfo.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SinglePageInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case singlepageinfo.FieldPageNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageNum(v)
		return nil
	case singlepageinfo.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case singlepageinfo.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case singlepageinfo.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown SinglePageInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SinglePageInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SinglePageInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SinglePageInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SinglePageInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SinglePageInfoMutation) ResetField(name string) error {
	switch name {
	case singlepageinfo.FieldBookID:
		m.ResetBookID()
		return nil
	case singlepageinfo.FieldPageNum:
		m.ResetPageNum()
		return nil
	case singlepageinfo.FieldPath:
		m.ResetPath()
		return nil
	case singlepageinfo.FieldName:
		m.ResetName()
		return nil
	case singlepageinfo.FieldURL:
		m.ResetURL()
		return nil
	case singlepageinfo.FieldBlurHash:
		m.ResetBlurHash()
		return nil
	case singlepageinfo.FieldHeight:
		m.ResetHeight()
		return nil
	case singlepageinfo.FieldWidth:
		m.ResetWidth()
		return nil
	case singlepageinfo.FieldModTime:
		m.ResetModTime()
		return nil
	case singlepageinfo.FieldSize:
		m.ResetSize()
		return nil
	case singlepageinfo.FieldImgType:
		m.ResetImgType()
		return nil
	}
	return fmt.Errorf("unknown SinglePageInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SinglePageInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SinglePageInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SinglePageInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SinglePageInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SinglePageInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SinglePageInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SinglePageInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SinglePageInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SinglePageInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SinglePageInfo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	created_at    *time.Time
	username      *string
	password      *string
	last_login    *time.Time
	age           *int
	addage        *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldAge:
		return m.Age()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
